=head1 NAME

Bric::Hacker - A guide for Bricolage hackers.

=head1 VERSION

$Revision: 1.35 $

=head1 DATE

$Date: 2003-03-01 20:02:39 $

=head1 DESCRIPTION

This document is designed to provide information useful to Bricolage
developers.  If you've got questions about hacking Bricolage that
aren't answered here please post to the Bricolage developer's
mailing-list (see below) and tell us about it.

=head1 MAILING LISTS

Bricolage has a number of mailing-lists that are relevant to developers:

=over 4

=item bricolage-general@lists.sourceforge.net

This is the mailing-list for normal Bricolage users.  This is a good
place to go with questions about how the application works and should
work.  To subscribe go to:

http://lists.sourceforge.net/lists/listinfo/bricolage-general

=item bricolage-devel@lists.sourceforge.net

This is the place to discuss Bricolage development, propose changes,
post patches and penetrate markets.  To subscribe go to:

http://lists.sourceforge.net/lists/listinfo/bricolage-devel

=item bricolage-commits@lists.sourceforge.net

This list gets an email for every commit to the CVS tree (see below
for more about CVS).  B<DO NOT POST TO THIS LIST!> To subscribe:

http://lists.sourceforge.net/lists/listinfo/bricolage-commits

=item bricolage-bugs@lists.sourceforge.net

This list gets an email for every bug-report submitted to Bugzilla
(see below for Bugzilla details).  B<DO NOT POST TO THIS LIST!> To
subscribe:

http://lists.sourceforge.net/lists/listinfo/bricolage-bugs

=back

=head1 CVS - THE CUTTING EDGE

If you're developing Bricolage then you should be working with the
latest code from CVS.  You can browse the CVS tree at:

   http://sourceforge.net/cvs/?group_id=34789

You'll also find information there on connecting to the repository to
checkout a working copy.

=head1 BUG TRACKING

Bricolage has a Bugzilla server dedicated to it:

   http://bricolage-bugzilla.about.com

You should use this system to report bugs in Bricolage.  If you're
looking for something to do you can also use the system to find open
bug and fix them.  For more things to do see L<Bric::ToDo|Bric::ToDo>.

=head1 SUBMITTING PATCHES

Patches should be generated using a C<cvs diff -u> command on each of
the files modified, from the root directory.  For example, if you made
changes to lib/Bric/Changes.pod and comp/foo.mc, you would generate a
diff by running this command from the root of your CVS checkout:

  cvs diff -u lib/Bric/Changes.pod comp/foo.mc > patch.txt

If you created one or more new files in your changes then you'll have
to add them to the patch separately using normal C<diff> against
C</dev/null>.  For example, if you created the file
C<inst/upgrade/1.9.1/solve_fermat.pl> then you would add this to
patch.txt with:

  diff -u /dev/null inst/upgrade/1.9.1/solve_fermat.pl >> patch.txt

Always create patches using the most recent CVS version if possible.
Send your patches to the bricolage-devel list mentioned above.

=head1 APPLYING PATCHES

Patches created using the method above can be applied using C<patch>
with the C<-p0> option from the root of your CVS checkout:

  patch -p0 < patch.txt

Make sure you check the results with C<cvs diff> before committing.

=head1 CODING STANDARDS

Try to follow the style of the existing Bricolage code.

=begin comment

We need to elaborate on this: POD, Mason, etc.

=end comment

Although historically the Bricolage code has not enforced whitespace rules, in
general, we try to encourage 4-space indents (2 spaces for continued lines)
and discourage the use of tabs. The following settings for some of the more
popular editors are thus recommended while editing Bricolage source code.

=head2 Emacs

We strongly recommend that you use C<cperl-mode> while editing Bricolage
sources in Emacs. Grab the latest version from the CPAN, install it, and then
place the following in your C<~/.emacs> file:

  (custom-set-variables
   '(case-fold-search t)
   '(cperl-indent-level 4)
   '(cperl-continued-statement-offset 2)
   '(cperl-tab-always-indent t)
   '(indent-tabs-mode nil))

Also, if you'd like to take advantage of the full functionality of
C<cperl-mode> and have it automatically parse all Perl source files, add these
settings, as well:

  (defalias 'perl-mode 'cperl-mode)
  (setq auto-mode-alist
        (append
         '(("\\.\\([pP]\\([Llm]\\|erl\\)\\|al\\|pod\\)\\'" . cperl-mode))
         auto-mode-alist))
    (setq cperl-hairy t)
    (setq interpreter-mode-alist (append interpreter-mode-alist
       '(("miniperl" . cperl-mode))))

When editing Bricolage Mason components, C<mmm-mode> can help. It's Mason mode
will parse Mason component files and use C<sgml-mode> in HTML spaces and
C<cperl-mode> in Mason blocks. Grab it from
L<http://mmm-mode.sourceforge.net/>, install it, and then add the following to
your C<~/.emacs> file to have it automatically parse your Bricolage Mason
component files:

  (add-to-list 'load-path "/usr/local/share/emacs/site-lisp")
  (require 'mmm-mode)
  (require 'mmm-mason)
  (setq mmm-global-mode 'maybe)
  (add-to-list 'auto-mode-alist '("/usr/local/bricolage/comp" . sgml-mode))
  (mmm-add-mode-ext-class 'sgml-mode "/usr/local/bricolage/comp" 'mason)

And if you need to examine the Mason object files created by Bricolage in
order to chase down bugs and such, you can use the C<cperl-mode> in those
files by adding this to your C<~/.emacs> file:

  (add-to-list 'auto-mode-alist '("/usr/local/bricolage/data/obj" . cperl-mode))

=head2 Vim

Rafael Garcia-Suarez has written a Vim indent macro which (for the most
part) duplicates the behavior of Emacs C<perl-mode>.  It is now, as of Vim
6.0, included in the Vim distribution and should be found in
C<$VIMRUNTIME/indent/perl>.  The easiest way to use it though is to place the
following line in your .vimrc:

    source $VIMRUNTIME/indent.vim

You'll also need to add these lines.

    set tabstop=8
    set softtabstop=4
    set shiftwidth=4
    set expandtab

The first three lines make Vim duplicate the behavior of Emacs in creating
the appearance of 4 space tabs with a mix of tabs and spaces.  This is
necessary for reading older Bricolage files which were written this way,
and haven't yet been re-tabbed.

The expandtab setting does the Right Thing under the new rules, in that it
doesn't use tabs at all, only spaces.

=head1 TESTING

All Bricolage patches should be accompanied by the necessary tests. You are
strongly encouraged to write comprehensive tests that thorougly test whatever
changes or additions you make to the Bricolage API. You are also strongly
encouraged to write tests for the current API, if you find that adequate tests
have not yet been written (and this is true in a great many places,
unfortunately). Although Bricolage does not yet support UI tests, we take our
API testing seriously, and so should you. Here's what you need to know to
write tests for Bricolage.

Bricolage contains a test suite based on L<Test::Class|Test::Class>. The test
classes live in the F<t/Bric> directory, and all subclass Bric::Test::Base. If
you're familiar with L<Test::More|Test::More>, then the syntax for how the
Test::Class-based classes work should be pretty readily apparent. See the
L<Test::Class|Test::Class> documentation for details. It's definitely worth a
read. If you have't used Test::More, its documentation is also a must-read.

Bricolage has two different sets of tests, those run by C<make test> and those
run by C<make devtest>. The former are standalone tests that don't rely on the
presence of a Bricolage database to be run. They can thus be run before
C<make install>. The idea here is that we offer a basic set of tests that can
be run via the standard Perl installation pattern of

  perl Makefile.PL
  make
  make test
  make install

The tests run by <make devtest> are intended to be run during development.
They require that a Bricolage database be installed and running. They will
C<SELECT>, C<INSERT>, C<UPDATE>, and C<DELETE> data from that database, so
C<make devtest> should B<never> be run against a production database. Indeed,
you should in general have a clean, fresh database installation to run the
tests against. Although the test suite makes every effort to clean up after
itself by C<DELETE>ing data it has added to the database, it is unfortunately
imperfect, and extra data will be left, especially in Group-related and
Attribute-related tables.

So, once more, B<C<make devtest> should B<never> be run against a production
database.>. 'Nuff said.

All of the tests are run by the F<inst/runtests.pl> script, which in turn
tells L<Test::Harness|Test::Harness> to execute F<t/Bric/Test/Runner.pm>. This
file will find all the necessary test classes, load them, and then run their
tests. F<inst/runtests.pl> takes a number of arguments to simplify the running
of scripts, including a list of Test files or classes to run, so that you can
just run the tests you need to run while you're developing new tests.
C<perldoc inst/runtests.pl> for more information.

Be sure to use the testing base classes in your test classes. For non-database
dependent tests (which are always in files named F<Test.pm>, use
L<Bric::Test::Base|Bric::Test::Base>. For development tests, use
L<Bric::Test::DevBase|Bric::Test::DevBase>, which inherits from
Bric::Test::Base. Be sure to read the documentation in these classes, as it
will help you to write your tests more effectively. Pay special attention to
the methods added to Bric::Test::DevBase, as they're there to help you clean
up any new records you've added to the database.

=head1 DEBUGGING

Bricolage is a complex application and debugging can be difficult.
Here are some tips to help you find bugs faster:

=over 4

=item *

Turn on QA_MODE in your bricolage.conf.  This will cause the UI to
display a bunch of useful data at the bottom of every page including
session state, cache state, cookies and CGI args.  QA_MODE turns on
PerlWarn (use warnings) and causes error messages to include more
information.  QA_MODE also enables Apache::Status at the URL
/perl-status which you can use to examine the state of the Perl
interpreter inside Apache.

=item *

Set the C<NO_TOOLBAR> directive to "0" or "Off" in F<bricolage.conf> to keep
Bricolage from popping up a new browser window without a toolbar.

=item *

Run Bricolage under the Perl debugger using the debug command with
bric_apachectl:

   bric_apachectl debug

This will start Apache in single-process mode ("httpd -X") and setup
Apache::DB to start the debugger on the each hit to the server.
You'll need to install the Apache::DB Perl module to use this command.

To run Bricolage under DDD (http://www.gnu.org/software/ddd) start ddd
as root and load bin/bric_apachectl.  Give it the argument "debug" and
run it.  When you issue a hit to the server the debugger will stop on
the first line of Bric::App::Handler::handler().  From there you can
set breakpoints inside Bricolage and debug normally.

If you prefer to run without the debugger using only the Apache single-process
mode, then run Bricolage using the command

   bric_apachectl single

=item *

Set DBI_DEBUG and DBI_CALL_TRACE to 1 in your bricolage.conf.
DBI_DEBUG records every database call in the logs complete with SQL
and arguments.  DBI_CALL_TRACE adds a a subroutine call trace for each
statement showing where the database call originated.  This generates
a lot of data but it can be very helpful.

=item *

Look at the database directly using psql.  Many bugs in Bricolage can
only be successful diagnosed by examining records being created in the
database.

=back

=head1 PERFORMANCE TUNING

Bricolage has two separate profiling systems that you can use to
extract performance data:

=over 4

=item *

To run Bricolage under the Devel::Profiler module set the PROFILE
variable on in your bricolage.conf file and restart your server.  This
will create a profiler/$$/tmon.out file in your Apache log directory
for each server process.  You can use dprofpp to analyze these files
after the server has been stopped with "bric_apachectl stop".  See the
Devel::Profiler documentation for more details.

=item *

The database profiler is activated by setting the DBI_PROFILE option
on in bricolage.conf.  This causes database profiling traces to be
written to the Aapche error_log during requests.  You can then use
bric_dbprof to analyze these trace.  See the bric_dbprof manpage for
details.

=back

B<CAUTION:> Neither of these options is appropriate for a production
system.

=head1 ACTIONS AND MOVERS

A relatively simple way to contribute to Bricolage is to provide actions
and movers. These are plugin modules that can add new functionality to
Bricolage without needing to make changes to the existing API.

An "action" is an act that is performed on files before they are distributed.
Say you want to clean the HTML of all of your HTML files before they're
distributed. You'll need to create an action to do this. Consult
L<Bric::Dist::Action> for information on how to create actions.

Say you need to distribute files via a protocol that Bricolage doesn't currently
support -- say, an new variant of FTP called "FooTP." You'll need to create a
new mover. Consult L<Bric::Dist::Action::Mover> for details on how to do that.

=head1 MERGING CHANGES FROM BRANCH TO TRUNK

If you're a Bricolage developer with permission to commit to the CVS
repository, you may occaisionally have to merge changes from a release branch
(where bug fixes are generally committed) into the trunk. Here's how to do it
with a minimum of hassle.

=over 4

=item 1

Determine if the branch checkout has been merged before. To do so, execute
this cvs command in the branch checkout:

  cd bricolage-branch-checkout/
  cvs -z3 -q status -v README

This command will output the status of the F<README> file, something like
this:

  ===================================================================
  File: README            Status: Up-to-date

     Working revision:    1.16.2.1
     Repository revision: 1.16.2.1        /cvsroot/bricolage/bricolage/README,v
     Sticky Tag:          rev_1_4 (branch: 1.16.2)
     Sticky Date:         (none)
     Sticky Options:      (none)

     Existing Tags:
          rev_1_4                   (branch: 1.16.2)
          rev_1_4_merge-2002-08-31  (revision: 1.16.2.1)
          dev_1_3_3                 (revision: 1.10)
          rev_1_2_merge-2002-04-03  (revision: 1.2.2.4)
          rel_1_2_3                 (revision: 1.2.2.4)


From this output, you can see that, for this branch (rev_1_4), the file was
tagged with the merge tag "rev_1_4_merge-2002-08-31". Thus we can tell that
the branch was last merged on August 31, 2002. If there had not been a tag
with the same version number as the branch, then we could determine that it
hadn't been merged before.

=item 2

If a new directory has been added to the branch since the last merge, you must
first manually add it to the trunk. This probably won't happen often, and is
most likely in the F<inst/upgrade> directory, where new directories are added
for upgrade scripts. If a directory is in the branch but not in the trunk,
simply create it and add it.

  mkdir inst/upgrade/1.4.1
  cvs -z3 -q add inst/upgrade/1.4.1

=item 3

If the branch has not been merged into the trunk before, cd into a checkout
from HEAD, make sure it's fully up-to-date, and do a simple merge:

  cd bricolage-head-checkout/
  cvs -z3 -q update
  cvs -z3 -q update -kk -j rev_1_4

Otherwise, do a merge from the most recently-dated merge tag. In the above
example, that would be "rev_1_4_merge-2002-08-31".

  cd bricolage-head-checkout/
  cvs -z3 -q update
  cvs -z3 -q update -kk -j rev_1_4_merge-2002-08-31 \
    -j rev_1_4

Note the use of the C<-kk> option. This option tells CVS not to evaluate
keywords in the files. This is crucial for merges, since keywords such as
C<$Revision $> B<will> be different. Not to worry, though; the keyword values
are always restored before releasing a new version. See
L<Creating Distributions|"CREATING DISTRIBUTIONS"> below.

=item 4

Resolve any conflicts (hopefully none, but they do happen occasionally) and
commit the changes to the trunk.

  cvs -z3 -q commit

=item 5

Tag the branch with today's date, so that future merges can decide to merge
only from this date on.

  cd bricolage-branch-checkout/
  cvs -z3 -q tag rev_1_4_merge-CCYY-MM-DD

=back

By following this methodology we should be able to minimize the number of
conflicts we get between merges. See the Karl Fogel and Moshe Bar's book "Open
Source Development with CVS, 2nd Edition", chapter 2, for a more detailed
explanation of the whys and wheres of this approach to merging CVS branches.

=head1 CREATING DISTRIBUTIONS

If you are a Bricolage release manager and you're getting ready to release a
new version, here are the steps you'll need to take to create a distribution
tarball. First, tag the release in CVS:

  cvs -z3 tag rel_1_x_x

If this is a major release, you'll need to create a new branch, so that it can
be maintained for bug fixes separately, and then tag the relase in that
branch.

  cvs -z3 tag -b rev_1_x
  cvs -z3 tag rel_1_x_x

Next, export the sources into a new directory. Be sure to use the C<-kkv>
option with C<export> so that the version numbers are all properly populated.

  cd /tmp
  cvs -z3 export -r rel_1_x_x -kkv bricolage
  cd bricolage
  make dist

This will create a distribution tarball in the bricolage directory. Copy this
tarbal somewhere, and do a full test with it, to make sure that Bricolage does
indeed build and properly install itself. If you have to go back and make any
changes, be sure to update the tag of any files you change and commit to
CVS. Once everything appears to be working properly, release!

=head1 AUTHOR

Sam Tregar <stregar@about-inc.com>

David Wheeler <david@wheeler.net>

=head1 SEE ALSO

L<Bric::Admin>, L<Bric::ToDo>

=cut

