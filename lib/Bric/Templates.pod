=pod

=head1 Name

Bric::Templates - Producing Templates on the Bricolage System

=head1 Version

$LastChangedRevision$

=head1 Date

$LastChangedDate$

=head1 Background

Before talking about templates, let's take a moment to discuss all the major
players in the publish process and get the terminology down. The major players
involved in publishing a story are:

=over

=item * Element Types

=item * Elements

=item * Templates

=item * Fields

=back

A quick word about each of these elements.

=head2 Element Types

These are content container definitions. They describe what kinds of content
that a story based on the element type will have. For instance, an "Editorial"
element type might define that an Editorial contains "An author name, a title,
and one or more paragraphs". Element types cannot affect the formatting or
look of a story, just the structure of the content.

=head2 Elements

Elements are instances of element types, and contain the content of stories.
The structure of Elements adheres to that defined by their types.

=head2 Templates

For a given element, a template formats its content for output. The formatted
content will then be saved in one or more files by the Bricolage burner.

=head2 Fields

Fields contain the content itself. Given an element type to constrain the
types of fields, a content author then enters the content into fields. Upon
preview or publication of the story, this content is then run through a
template to produce one ore more output files.

=head1 Template Overview

=head2 More About Elements

The first place one starts when making a new story is with an element. An
element is based on an element type, which defines the structure of a story.
For example, a "Column" element type might define a column story as having:

=over

=item * An author field

=item * A column topic field

=item * One or more paragraph fields

=back

Given this definition, a content author creating a new column element will
have these three types of fields available to her.

Elements may also contain other elements. For example, the "Column" element
type above might be used for a column reviewing music. A music column might
want to have a short blurb about the albums that it reviews. So we create
another element type called "Music Blurb" with these fields:

=over

=item * Artist name

=item * Album name

=item * Label name

=item * Summary

=back

Now in our "Column" element type we can add the "Music Blurb" element type as
a I<Subelement>. So now the structure looks like this:

=over

=item * An author field

=item * A column topic field

=item * One or more paragraph fields

=item * Any number of Music Blurb subelements

=back

Now a content author editing a Column story has the ability to add an author
field, a topic for the column, a few paragraphs, and a blurb about the album
she is reviewing. Element types can defined elements to be nested as deeply as
needed. So an element can contain an subelement, that contains another
subelement, etc.

The most important thing to understand about element types is that they simply
define the structure of the content that the author is allowd to use when
creating or editing a story. The element type has no bearing on the actual
content itself, or the formatting of that data!

=head2  Template Basics

Templates are the objects that actually format content. There are three basic
types of templates: element templates, category templates, and utility templates.
We'll start with the most common, element templates.

An element template is associated with a single element type and knows how to
format content for elements of that type. For example, for our hypothetical
"Column" element type, we might create a template to output HTML like this:

  <html>
    <head><title>$column_topic</title></head>
    <body>
      <h1>$column_topic</h1>
      <h2>By $author</h2>

      <p>$para1</p>
      <p>$para2</p>
      ...
      display_element(music_blurb)
      ...
    </body>
  </html>

This example doesn't represent the actual syntax for inserting values, but is
meant to convey a template's relationship to an element. We'll get into the
nuts and bolts later.

Note that the Music Blurb element element is referenced by its "key name",
which is defined by the element type, and is simply passed to a display
function. Remember, element templates represent the content for only a single
element; another element template formats a the Music Blurb element.

=head2 Templates And Categories

While a template formats the contents of a single element, there may be many
templates that all format the same element. Why? Well, templates also belong
to a single category. Imagine that the site for which we've created the
current element and template examples is an arts and media site. There might
be different sections of the site: one for music, one for theater, and one for
gallery art. This site might therefore define the following categories:

=over

=item * music

=item * theater

=item * gallery

=back

Categories may contain subcategories. This is just to provide greater
categorization detail:

=over

=item * music

=item * music/dj

=item * music/classical

=item * music/rock

=item * theater

=item * theater/broadway

=item * theater/community

=item * gallery

=item * gallery/painting

=item * gallery/sculpture

=back

In addition to these categories, Bricolage always provides a "root" category
for each site. If you don't want something to be specific to a particular
category, you can assign it to the root category. Root is usually shown as "/"
in Bricolage, and category URIs always end in "/":

=over

=item * /

=item * /music/

=item * /music/dj/

=item * /music/clasical/

=item * /music/rock/

=item * ...

=back

So, what does this all mean for templates? By allowing many templates, each
associated with a different category, to format the same element, we can have
a custom format for the content in each section of the site. Say we want to
have a column run in all the major categories of our site. That is, we want a
Music column, a Theater column, and a Gallery column. We want to collect the
same data for each of these columns, but we want the data to look different
when published to each of these categories. To do so, you can simply create a
column element template in each of those categories.

But note that a new template for I<every single> category is not necessary.
The "DJ", "Classical" and "Rock" subcategories will all default to using the
template associated with the "Music" category. If there is no need to change
how the content is displayed between I<any> category, you can simply create a
template associated with the root category, and column stories in any category
will use it. In fact, the vast majority of Bricolage installations have all
element templates defined in the root category, with only the occaisional
element template defined in a subcategory on an as-needed basis.

=head2 Templates And Output Channels

Another attribute of a template is its association with an "Output Channel."
An output channel is a collection of templates designed to format stories in a
common format. So it's not unsual to have several output channels, such as
XHTML, RSS, or WML, each of which outputs the contents of stories in a
specific format.

Furthermore, output channels can I<include> templates from other output
channels. For example, an "Email" output channel might include templates from
the XHTML output channel. Thus, when a story is published to the Email output
channel, if the burner cannot find its templates in the Email output channel,
it will look for them in the XHTML output channel. This approach to template
sharing can be extremely useful for maintaining the consistency of formatting
across output channels, as well as to facilitate code reuse.

=head2 Bringing It All Together

By now you might be asking, I<Where do all my templates go, how does the
system know what categories have templates in them, and how are they used
during a publish?>

Now, while there should be no need to manipulate templates directly on the
bricolage Server's filesystem (and it could cause the Bricolage system
considerable confusion, anyway), let's briefly examine how the files are laid
out. Hopefully, this excercise will make clear a few things about templates
and publishing.

Let's start with names. Element types are given key names when they are
created, and the key names uniquely identify element types throughout
Bricolage. In our examples above, we created a "Column" element type. When you
create an element template and choose its associated element type, it
automatically assumes the key name of that element type. So, if our element
type is named "Column" and its key name is "column", our template is will also
be named "Column" and its base file name will be "column".

The template code may be written in one of four templating languages: Mason,
Template Toolkit, PHP, or HTML::Template. Each output channel is associated
with a templating language, so all templates in a single output channel (or
any output channel it includes) will be written in the same templating
language. The template file suffix varies depending on the templating
language: ".mc" for Mason, ".tt" for Template Toolkit, ".php" for PHP, or
".pl" or ".tmpl" for HTML::Mason. (The examples in this tutorial will be in
Mason, Template Toolkit, and PHP; See L<Bric::HTMLTemplate|Bric::HTMLTemplate>
for a tutorial on HTML::Template templates, which are a bit different from the
others.) So the filenmame for our Column element template would be either
F<column.mc>, F<column.tt>, F<column.php>, F<column.pl> or F<column.tmpl>.

The category associated with a template determines the path of the template
file. So for a template in the F</music/rock/> category, the path to the
template would be F</music/rock/column.mc>.

Finally, the output channel is also used as a part of the path on the file
system. Rather than take the output channel's name, its ID is used. Let's just
say that the ID for primary channel output containing our Column element
template is 1. So, our column template would live in
F<oc_1/music/rock/column.mc>.

If we assume that our element root is $COMP_ROOT, the full path to our
template is F<$COMP_ROOT/oc_1/music/rock/column.mc>. In template code, you
don't need to worry about the full path, however, just the relative path,
F</music/rock/column.mc> or even just F<music/rock/column.mc>. The individual
templating architectures handle the searching for templates in the proper
output channel directories using their own path searching algorithms.

=head2 Publish Examples

So, let's assume that we have three Column templates in a single Mason output
channel: one associated with the root category, one associated with the Music
category, and one associated with the Sculpture Gallery category. Their
full path names would be:

  /column.mc
  /music/column.mc
  /gallery/sculpture/column.mc

Now, say that somebody creates a new column. When creating a new story, the
author has the opportunity to associate it with one or more categories. The
table below illustrates which F<column.mc> template would be used for a
publish in a particular category.

    Category where Story Published       Template element Used
    -------------------------------      ----------------------------
    /music/rock/                         /music/column.mc
    /theater/broadway/                   /column.mc
    /gallery/                            /column.mc
    /gallery/art/                        /column.mc
    /gallery/sculpture/                  /gallery/sculpture/column.mc

As you can see, a story published in a particular category will look I<up> the
category URI to find an element template to format it if it can't find it in
the the story's own category. This functionality works identically for all
supported templating architectures.

Note that in the case of the stories published in "/music/rock/" and in
"/gallery/sculpture/", templates were found before the root template at
F</column.mc>. It's important to realize that element templates do not
I<chain>. That is, the story published to "/music/rock/" will I<not> be
formatted by both F</music/column.mc> I<and> F</column.mc>. Once an element
template is found, the search stops. Thus element templates in subcategories
I<override> element templates in parent categories.
Mason

=head2 One Final Trick

Although element templates do not chain, sometimes you might want formatting
code to be inherited rather than overridden. If you're familiar with Mason you
may have noticed the similarity between how element templates are handled and
the Mason concept of "dhandlers". In fact in Mason output channels, story
element templates I<are> dhandlers. Subelement templates of course are not,
but they do enjoy the same category URI lookup algorithm when the burner
searches for them. The other category architectures use the same algorithm for
all element templates.

But there's another type of template that's useful for inheriting formatting
behavior from parent categories. These templates are known as "category
templates." A category template resides in a category, and wraps the execution
of story element templates. In fact, in Mason output channels, category
templates are implemented as Mason "autohandlers", while in Template Toolkit
output channels, they're implemented as "wrappers". The PHP and HTML::Template
burners emulate autohandlers and wrappers, as well. Their file names are
F<autohandler> in Mason, F<wrapper.tt> in Template Toolkit, F<cat_tmpl> in
PHP, and F<category.pl> or F<category.tmpl> in HTML::Template. In any case, in
Bricolage, these templates are all known as "category templates," regardless
of the templating language in which they're implemented.

Category templates enjoy a different lookup algorithm. Like Mason's
autohandlers, category templates are executed from the root category C<down>
the category URI. Furthermore, unlike element templates, the search does not
stop as soon as a category template is found. Rather, it continues down the
category URI path, executing each category template it finds in a cascading
execution pattern.

For example, say that we have the following category templates defined in a
Mason output channel:

  /autohandler
  /music/dj/autohandler
  /gallery/autohandler

This table outlines how they would be executed for stories in a select number
of categories:

    Category where Story Published       Category Templates Executed
    -------------------------------      ----------------------------
    /music/rock/                         /autohandler
    /music/dj/                           /autohandler, /music/dj/autohandler
    /theater/broadway/                   /autohandler
    /gallery/                            /autohandler, /gallery/autohandler
    /gallery/art/                        /autohandler, /gallery/autohandler

Given a category URI, Bricolage searches for the first possible category
template in that path, and then works its way down the path, executing any
other autohandlers until it finally reaches the story's category. Then it
starts searching for the story element template. In this way, category
templates wrap the execution of story element templates for any type of story
published in the output channel. This makes them ideal for the headers and
footers that are common to all pages on a site (for a root-level category
template), or category-specific headers/navigation, etc. (for subcategory
category templates).

=head2 Category Template Example

What good are category templates? Let's continue with our running example of
the arts and media site. Let's say that, regardless of what type of story is
published, you want the same basic HTML header and footer. Whether the story
is a "column" or a "review" or an "editorial," you want the same header and
footer on every page. The easiest and most efficient way to do this is by
creating a root-level category template.

If we create a new category template in the root category of a Mason output
channel (for this example, we'll assume an output channel with ID 1), then
we'll get the file:

  $COMP_ROOT/oc_1/autohandler

The code for this template might look like this:

  <html>
    <head><title>Arts n' Media</title></head>
    <body>

      <ul id="nav">
        <li><a href="/music">Music</a></li>
        <li><a href="/theater">Theater</a></li>
        <li><a href="/gallery">Gallery</a></li>
      </ul>

      <div id="content">
  % $burner->chain_next(@_);
      </div>

      <p id="foot">The contents of this site are licensed under a <a
      rel="license" href="http://creativecommons.org/licenses/by-nc/2.0/"
      title="Creative Commons Attribution-NonCommercial License">Creative
      Commons License</a>.</p>

    </body>
  </html>

If you're familiar with Mason, most of this should look pretty normal. The
only difference from your standard Mason autohandler is the call to C<<
$burner->chain_next(@_) >> rather than C<< $m->call_next >>. This is where
Bricolage will set things up and call C<< $m->call_next >> internally to
execute the proper element template and output the story document content.
Given this category template, if we publish a column to the '/music/rock/'
category, the following templates will be used in this order:

    $COMP_ROOT/oc_1/autohandler
    $COMP_ROOT/oc_1/music/rock/column.mc

The content that F<column.mc> outputs after being run will wrapped by the HTML
in the category template. Furthermore, because the story element template is
implemented as a dhandler, and the category template is implemented as an
autohandler, Mason's inheritance methodology will work pefectly. If you declar
a C<< <%method> >> or C<< <%attr> >> block in F<column.mc>, then the category
template can call it.

If we create a new category template in the root category of a Template
Toolkit output channel (for this example, we'll assume an output channel with
ID 2), then we'll get the file:

  $COMP_ROOT/oc_2/wrapper.tt

The code for this template might look like this:

  <html>
    <head><title>Arts n' Media</title></head>
    <body>

      <ul id="nav">
        <li><a href="/music">Music</a></li>
        <li><a href="/theater">Theater</a></li>
        <li><a href="/gallery">Gallery</a></li>
      </ul>

      <div id="content">
  [% CONTENT %]
      </div>

      <p id="foot">The contents of this site are licensed under a <a
      rel="license" href="http://creativecommons.org/licenses/by-nc/2.0/"
      title="Creative Commons Attribution-NonCommercial License">Creative
      Commons License</a>.</p>
    </body>
  </html>

Here the behavior is identical to your standard Template Toolkit wrapper. Unlike
the Mason autohandler, however, the execution order is reversed:

    $COMP_ROOT/oc_2/music/rock/column.tt
    $COMP_ROOT/oc_2/wrapper.tt

The formatted content output by F<column.tt> will be stored in the C<CONTENT>
variable in the Template Toolkit stash, and then the wrapper template will be
executed.

Any values stored in the stash by the element template are available to either
wrapper template, and those stored by the "/music/" wrapper template would be
available to the root wrapper template. This functionality roughly corresponds
with Mason inheritance.

As for PHP, its category template is, in fact, almost identical to the
Template Toolkit category template:

  <html>
    <head><title>Arts n' Media</title></head>
    <body>

      <ul id="nav">
        <li><a href="/music">Music</a></li>
        <li><a href="/theater">Theater</a></li>
        <li><a href="/gallery">Gallery</a></li>
      </ul>

      <div id="content">
  <?= $content ?>
      </div>

      <p id="foot">The contents of this site are licensed under a <a
      rel="license" href="http://creativecommons.org/licenses/by-nc/2.0/"
      title="Creative Commons Attribution-NonCommercial License">Creative
      Commons License</a>.</p>
    </body>
  </html>

As with Template Toolkit wrappers, the story element template executes first,
and the formatted output of the element template is stored in the C<$content>
global variable for access by the category template. Furthermore, because the
execution order is the same:

    $COMP_ROOT/oc_3/music/rock/column.php
    $COMP_ROOT/oc_3/cat_tmpl

You can set up global variables (or better, a global associative array) in
your element templates and have them available to the category template. This
equates to Template Toolkit's stash and likewise corresponds to Mason's
inheritance features.

=head3 Subcategory Category Template Example

As a last example of the chaining of category templates, let's say that we
wanted some special HTML to appear just in the music section, regardless of
what type of story we were publishing. Again, the best approach is to create a
category template in the music category. The Mason version would live in
the Music category directory:

    $COMP_ROOT/oc_1/music/autohandler

The code for this category template might look like this:

        <h1>Music</h1>
        <div class="music">
          <img src="/ui/img/music_icon.png" alt="Air Guitar />
        % $burner->chain_next(@_);
        </div>

So, given this category template, in combination with the original root-level
category template, if we again publish a column to the '/music/rock/'
category, the following templates will be executed in this order:

    $COMP_ROOT/oc_1/autohandler
    $COMP_ROOT/oc_1/music/autohandler
    $COMP_ROOT/oc_1/music/rock/column.mc

After publishing this column, the final page output will look like this (for
now, just assume that F<column.mc> outputs the story content in C<< <p> >>
tags):

  <html>
    <head><title>Arts n' Media</title></head>
    <body>

      <ul id="nav">
        <li><a href="/music">Music</a></li>
        <li><a href="/theater">Theater</a></li>
        <li><a href="/gallery">Gallery</a></li>
      </ul>

      <div id="content">
        <h1>Music</h1>
        <div class="music">
          <img src="/ui/img/music_icon.png" alt="Air Guitar />
          <p>This is a test column.</p>
        </div>
      </div>

      <p id="foot">The contents of this site are licensed under a <a
      rel="license" href="http://creativecommons.org/licenses/by-nc/2.0/"
      title="Creative Commons Attribution-NonCommercial License">Creative
      Commons License</a>.</p>
    </body>
  </html>

=head1 Writing Templates

The above sections should give you an idea of how to create a template -- what
it means to associate a template with an element, a category, and an output
channel. Now let's talk a little about actually writing template code.

Writing template code is no different than writing Mason code. If you've written
Mason code, you should have no problem writing templates. If you have not
written Mason code before, I suggest you get familiar with it by reading
L<HTML::Mason::Devel>. A tutorial on Mason is beyond the scope of this document.

=head2 Terminology

Given that template code is just Mason, Template Toolkit, PHP, or
HTML::Template code, the only thing you need to know is how to access the
story data. So let's take a small break to discuss terminology for story
objects.

Stories are based on element types. Before you can create a new story, you
must select an element type upon which your story will be based. Based on your
selection, you will then be given a list of available fields for which you can
enter content. If we use the "column" element type that we defined earlier,
our fields will be:

=over

=item *

An author field

=item *

A column topic field

=item *

1 or more paragraph fields

=item *

1 or more Music Blurbs

=back

Now, if you remember, the author field, column topic field, and paragraph
fields are all just text fields, while the music blurb is a subelement of the
column element. This gives us two varieties of elements that can be in a
story: "Container Elements" and "Field Elements", also generally referred to
as "Elements" and "Fields", respectively.

In the interest of keeping things simple for the story authors, the Bricolage
user interface uses a single term for both types of elements, "Element." Early
user testing showed that authors didn't know or care about the difference
between field elements and container elements. But this should have little
bearing on your job as a template developer. You can simply think of them as
"Container Elements" and "Field Elements," or, collectively, as "Elements".

So our new story based on the column element type may contain the following
elements:

=over

=item *

An author field element

=item *

A topic field element

=item *

A paragraph field element

=item *

A music blurb container element

=back

Now that we know what a story can have and how to refer to them, let's look at
the methods to access them.

=head2 Available Objects and Methods

First, there are three variables exported into the global space of each
templating architecture for use in templates. These are:

=over

=item $story

The story object

=item $element

The current element object

=item $burner

The burn system object

=back

=head3 Story Object Methods

The story object repressents the story document being published. It is used to
access all the metadata of a story. It can be used to indirectly access the
actual content of the story, but there is a simpler way to do so, which we'll
get to shortly. You can read the full list of methods callable on the story
object by reading
L<Bric::Biz::Asset::Business::Story|Bric::Biz::Asset::Business::Story>, but
let's highlight some of the most important and useful ones here:

=over

=item C<< $story->get_title >>

Retrieve the title of this story.

=item C<< $story->get_description >>

Retrieve the description for this story.

=item C<< $story->get_cover_date >>

Returns the story's cover date, which is an arbitrary date associated with
the story.

=item C<< $story->get_publish_date >>

The date when the story was most recently published; always available when
publishing a story, but will be C<undef> when previewing if the story has not
been published.

=item C<< $story->get_first_publish_date >>

The date when the story was first published; always available when publishing
a story, but will be C<undef> when previewing if the story has not been
published.

=item $story->get_primary_uri

Retrieve the primary URI for the story, which is determined by its primary
category and the URI format of its primary output channel.

=back

=head3 Element Object Methods

The element object contains the content of a story. Since a story is based
upon an element type, the field and container elements in the $element object
are defined by its element type. so if the element type defined "author,"
"topic," and "paragraph," fields, you know that you can access those field
elements via $element. Where $element really becomes interesting, however, is
in its container elements.

In our example, we had defined a "music_blurb" element element type as a
subelement of the "column" element type. Because it is not a story type
element, there can be no "music_blurb" story; it can only be part of a larger
"column" story. However, "music_blurb", just like any other element type,
needs to have a template that knows how to format it. So while burning our
"column" story, we will at some point have to call out to the "music_blurb"
template to format our "music_blurb" element. When the "music_blurb" template
executes, $story will still contain our "column" story object, but $element
will contain an instance of a "music_blurb" element, and will allow access to
the field and container subelements defined by the "music_blurb" element type.

Sound confusing? Well, you can read the full documentation for the interface
of an element object in
L<Bric::Biz::Element::Container|Bric::Biz::Element::Container>, as well as its
parent class in L<Bric::Biz::Element|Bric::Biz::Element>, but let's just go
over some of the more significant methods callable on $element, and we'll get
to an example soon enough.

=over

=item C<< $element->get_field($key_name, $num) >>

This method returns the field object with the key name given by the $key_name
argument. For example, if the element object was a "column" element, you could
use "author", "topic", or "paragraph" for the key name to get the
corresponding field.

The $num argument is optional. It is meant for fields that can occur more than
once, such as "paragraph"s in our "column" example. If $num is not given then
it defaults to "1", meaning that the the first instance of the field
identified by $key_name will be returned. The ordering is determined by the
content author (you want all your paragraphs to be in the correct order,
right?).

=item C<< $element->get_value($key_name, $num, $format) >>

This method is a convenient shortcut for

  $elemnt->get_field($key_name, $num)->get_value($format);

In other words, it returns the content associated with the field element given
by $key_name. For example, if the element object was a "column" element, you
could use "author", "topic", or "paragraph" for the key name to get the value
stored for the corresponding field.

The $format argument is optional, and may contain a C<strftime> format string.
Natually, this is useful only for date fields, and is ignored by all others.
If not specified, it defaults to the value stored in the "Date/Time Format"
global preference. See L<DateTime|DateTime> for full documentation of the
C<strftime> format.

=item C<< $element->get_fields(@key_names) >>

Returns a list or anonymous array of the field subelements of the element. If
called with no arguments, it returns all of the field subelements, in the
order specified by the content editor. They can and will be mixed. For
example, for our "column" example, it might return two paragraphs, then a
topic, then three more paragraphs, then an author, and then two more
paragraphs.

If you only want specific fields but to still get them in order, simply
pass in a list of the key names of the fields you're interested in. For
example, called like this:

  my @elems = $element->get_fields(qw(paragraph topic));

only paragraph and topic fields will be returned, but still in the order
specified by the content author.

=item C<< $element->get_container($key_name, $num) >>

This method returns a container element object with the key name specified by
the $key_name argument. This object is of the same type as $element. Usually
you will just pass it to a method that will execute the correct template for
you.

As with C<get_value()>, the $num argument is optional, and is used to retrieve
specific container elements that occur more than once in a given story. If
$num is not given then it defaults to "1", meaning that the value for the
first instance of the container element identified by $key_name will be
returned. The ordering is determined by the content author.

=item C<< $element->get_containers(@key_names) >>

This method corresponds to C<get_fields()> but returns a list or anonymous
array of the container subelements of the element. If called with no
arguments, it returns all of the container subelements, in the order specified
by the content editor. They can and will be mixed. If you only want specific
fields but to still get them in order, simply pass in a list of the key names
of the fields you're interested in.

=item C<< $element->get_elements(@key_names >>

This method is perhaps the most used method on the $element object. It returns
a list or anonymous array anony of both container I<and> field element
objects. Again, pass in a list of field and/or container element type key
names to get back only elements based on those element types. For
example, called like this:

  my @elems = $element->get_fields(qw(paragraph topic music_blurb));

only paragraph, topic, and music_blurb elements will be returned, but still in
the order specified by the content author.

=item C<< $element->get_place >>

Content authors have the opportunity to arrange the elements of their story in
a particular order. This method returns a number giving this container
element's place among all other subelements of $element (both data and
container).

If $element is the element object for the story itself (i.e. the "column"
element of a "column" story) C<get_place()> will return 1.

=item C<< $element->get_object_order >>

For a container element that can occur more than once in a story, this method
returns its place among container elements of the same type. For example a
"column" story might contain several "music_blurb" container elements. If
$element happens to be the second of three "music_blurb" container elements,
C<get_object_order()> will return 2.

If $element is the element object for the story itself (i.e. the "column"
element of a "column" story) C<get_object_order()> will return 1.

=item C<< $element->get_key_name >>

Return the key name of the container element.

=back

=head3 Field Object Methods

The C<get_field()>, C<get_fields()>, and C<get_elements()> methods each can
return field elements. These are represented by the
L<Bric::Biz::Element::Field|Bric::Biz::Element::Field> class, which like the
container element class, inherits from
L<Bric::Biz::Element|Bric::Biz::Element>. But we'll cover their most important
methods here:

=over

=item $delem->get_value

Returns the data associated with this data element.

=item $delem->get_place

Same concept as the container element 'get_place' method.

=item $delem->get_object_order

Same concept as the container element 'get_object_order' method.

=item $delem->get_key_name

Returns the name of this data element.

=back

Finally, to distinguish between data and container element objects you can call
this method on any type of element:

=over

=item $element->is_container

Returns 1 if this is a container element object and 0 if this is a data element
object.

=back

I<Burn System Object Methods>

Here are the methods available via the burn system object.

=over

=item $burner->chain_next

From an autohandler template, this calls the next autohandler, or the specific
story template.

=item $burner->display_element($element)

This takes either a data element object or a container element object.

Given a container element object, this method will locate the proper template
and output the results of burning that template.

Given a data element object, this method will simply output the data of that
data element.

=item $html = $burner->sdisplay_element($element)

An sprintf version of $burner->display_element($element),
that is it returns the HTML as a string instead of directly
outputting it to the browser.

=back

=head2 A Template Example

For this template example, let's use the 'column' Element included in the
Bricolage system as our story. This 'column' is a little different than the one
we've been discussing. Here is the layout for this Element:

=over

=item Element Column

=over

=item *

Data element 'deck'

=item *

Container element 'page'

=back

=item Element Page

=over

=item *

Data element 'paragraph'

=item *

Data element 'pull quote'

=item *

Data element 'next'

=item *

Data element 'previous'

=item *

Container element 'inset'

=back

=item Element Inset

=over

=item *

Data element 'copy'

=back

=back

There are few things to note here. Notice that this story structure is 3 levels
deep rather than our two levels before. Additionally, the 'page' Element was
created with a flag marking it as a paginated Element. This means that Mason
will automatically start a new output file for every 'page' Element burned,
provided it is burned with the display_pages() method.

Here is the code for the 'column' template:

    <!-- The column element -->
    <html>
        <head>
            <title><% $story->get_title %></title>
        </head>
        <body>

    % $burner->display_pages('page');

        </body>
    </html>

This code simply iterates through each 'page' container element in the 'column'
story and displays it. Remember that the page element was created with the
'paginated' flag and will start a new output file so we'll save the real HTML
for the 'page' element. Note that we skip the 'deck' data element. This element
is meant for when this is used in a related story context. Using related stories
will be discussed later in another document.

Next let's look at some example code for the 'page' element:

    <!-- The page element -->
    % my $page = $burner->get_page;

    <!-- Only display this title if we are on the first page -->
    % unless ($page) {
            <h1><% $story->get_title %></h1>
    % }

    <!-- Show the content for this element -->
    <%perl>
        foreach my $e ($element->get_elements) {
            if ($e->has_name('paragraph')) {
                $m->out('<p>');
                $burner->display_element($e);
                $m->out('</p>');
            } elsif ($e->has_name('pull_quote')) {
                $m->out('<p><i>');
                $burner->display_element($e);
                $m->out('</i></p>');
            } elsif ($e->has_name('inset')) {
                $burner->display_element($e);
            }
        }

        my $next_txt = $element->get_value('next');
        my $prev_txt = $element->get_value('previous');
        my $next = $burner->next_page_file;
        my $prev = $burner->prev_page_file;
    </%perl>

    <!-- Show previous page link if it exists -->
    % if ($prev and $prev_txt) {
            [Page <% $page %>]&lt;&lt;&lt;
            <a href="<% $prev %>"><% $prev_txt %></a>
    % }

            &nbsp;&nbsp;&nbsp;

    <!-- Show next page link if it exists -->
    % if ($next and $next_txt) {
            <a href="<% $next %>"><% $next_txt %></a>
            &gt;&gt;&gt;[Page <% $page + 2 %>]
    % }

This code outputs the main HTML, outputting a header if this is the first page
of the column, followed by the data for this story. After the data is output the
'previous' and 'next' links are displayed. Note that in the foreach loop
iterating over all elements the method 'display_element' is used to display both
data and container elements. For the data elements we could have used:

    $m->out($e->get_value);

to return the data. Also, it is important to realize that there are no
restrictions against having a container and a data element with the same name.
While this is unlikely to happen, if it were true for the 'column' element the
above code would run fine, but may not output what is expected.

Finally here is the template code for the 'inset' container element:

    <!-- The inset element -->
    <table width="570" border="2">
        <tr><td>
    % $element->get_value('copy');
        </td></tr>
    </table>


That's about it. The above code for the three Elements, once used to create new
templates and deployed, should allow you to publish 'column' stories. Make sure
you create your templates in the root category to ensure you can publish a story
to any category.

=head1 APPENDIX

=head2 Class Names

    Object Type         Associated Perl Class
    -----------         ---------------------
    Element Type        Bric::Biz::ElementType
    Template            Bric::Biz::Asset::Template
    Story               Bric::Biz::Asset::Business::Story
    Element             Bric::Biz::Element
    Field Element       Bric::Biz::Element::Field
    Container Element   Bric::Biz::Element::Container
    Burn System         Bric::Util::Burner

=head2 Glossary

=over

=item autohandler

A mason concept. As applied to Bricolage, it is a variation on a template
that can form a line of 'chained' templates.

=item Burn System

The element of the Bricolage system that joins story data with existing
templates.

=item Category

A way of organizing a web site into separate sections.

=item Container element

An element containing structured data based on an Element.

=item Data element

An element that represents textual/simple data.

=item dhandler

A Mason concept. Templates behave in a similar manner to dhandlers.

=item Element

The "form" of a story or story part.

=item element

An instance of an Element in a story.

=item  Mason

An apache/perl templating system.

=item Output Channel

A destination for published data.

=item Story

The data to be published.

=item Template

An output format for published data.

=back

=head1 AUTHOR

Garth Webb <garth@perijove.com>

=head1 SEE ALSO

L<Bric|Bric>,
L<Bric::AdvTemplates|Bric::AdvTemplates>,
L<Bric::Biz::ElementType|Bric::Biz::ElementType>,
L<Bric::Biz::Asset::Template|Bric::Biz::Asset::Template>,
L<Bric::Biz::Asset::Business::Story|Bric::Biz::Asset::Business::Story>,
L<Bric::Biz::Element|Bric::Biz::Element>,
L<Bric::Biz::Element::Field|Bric::Biz::Element::Field>,
L<Bric::Biz::Element::Container|Bric::Biz::Element::Container>,
L<Bric::Util::Burner|Bric::Util::Burner>

=cut
